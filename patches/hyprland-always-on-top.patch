diff --git a/src/Compositor.cpp b/src/Compositor.cpp
index 9c806fdd..be1b40de 100644
--- a/src/Compositor.cpp
+++ b/src/Compositor.cpp
@@ -921,9 +921,23 @@ PHLWINDOW CCompositor::vectorToWindowUnified(const Vector2D& pos, uint8_t proper
         }
     }
 
+    // prioritize always on top windows
+    std::vector<PHLWINDOW> alwaysOnTopWindows;
+    std::vector<PHLWINDOW> windows;
+    windows.reserve(g_pCompositor->m_windows.size());
+
+    for (auto const& w : m_windows) {
+        if (w->m_alwaysOnTop)
+            alwaysOnTopWindows.emplace_back(w);
+        else
+            windows.emplace_back(w);
+    }
+
+    windows.insert(windows.end(), alwaysOnTopWindows.begin(), alwaysOnTopWindows.end());
+
     auto windowForWorkspace = [&](bool special) -> PHLWINDOW {
         auto floating = [&](bool aboveFullscreen) -> PHLWINDOW {
-            for (auto const& w : m_windows | std::views::reverse) {
+            for (auto const& w : windows | std::views::reverse) {
 
                 if (special && !w->onSpecialWorkspace()) // because special floating may creep up into regular
                     continue;
@@ -2153,7 +2167,7 @@ void CCompositor::setWindowFullscreenState(const PHLWINDOW PWINDOW, Desktop::Vie
 
     // make all windows and layers on the same workspace under the fullscreen window
     for (auto const& w : m_windows) {
-        if (w->m_workspace == PWORKSPACE && !w->isFullscreen() && !w->m_fadingOut && !w->m_pinned)
+        if (w->m_workspace == PWORKSPACE && !w->isFullscreen() && !w->m_fadingOut && !w->m_pinned && !w->m_alwaysOnTop)
             w->m_createdOverFullscreen = false;
     }
     for (auto const& ls : m_layers) {
diff --git a/src/debug/HyprCtl.cpp b/src/debug/HyprCtl.cpp
index 41b34e8a..27591ed6 100644
--- a/src/debug/HyprCtl.cpp
+++ b/src/debug/HyprCtl.cpp
@@ -385,6 +385,7 @@ std::string CHyprCtl::getWindowData(PHLWINDOW w, eHyprCtlOutputFormat format) {
     "pid": {},
     "xwayland": {},
     "pinned": {},
+    "alwaysOnTop": {},
     "fullscreen": {},
     "fullscreenClient": {},
     "grouped": [{}],
@@ -400,23 +401,23 @@ std::string CHyprCtl::getWindowData(PHLWINDOW w, eHyprCtlOutputFormat format) {
             sc<int>(w->m_realPosition->goal().y), sc<int>(w->m_realSize->goal().x), sc<int>(w->m_realSize->goal().y), w->m_workspace ? w->workspaceID() : WORKSPACE_INVALID,
             escapeJSONStrings(!w->m_workspace ? "" : w->m_workspace->m_name), (sc<int>(w->m_isFloating) == 1 ? "true" : "false"), (w->m_isPseudotiled ? "true" : "false"),
             w->monitorID(), escapeJSONStrings(w->m_class), escapeJSONStrings(w->m_title), escapeJSONStrings(w->m_initialClass), escapeJSONStrings(w->m_initialTitle), w->getPID(),
-            (sc<int>(w->m_isX11) == 1 ? "true" : "false"), (w->m_pinned ? "true" : "false"), sc<uint8_t>(w->m_fullscreenState.internal), sc<uint8_t>(w->m_fullscreenState.client),
-            getGroupedData(w, format), getTagsData(w, format), rc<uintptr_t>(w->m_swallowed.get()), getFocusHistoryID(w),
+            (sc<int>(w->m_isX11) == 1 ? "true" : "false"), (w->m_pinned ? "true" : "false"), (w->m_alwaysOnTop ? "true" : "false"), sc<uint8_t>(w->m_fullscreenState.internal),
+            sc<uint8_t>(w->m_fullscreenState.client), getGroupedData(w, format), getTagsData(w, format), rc<uintptr_t>(w->m_swallowed.get()), getFocusHistoryID(w),
             (g_pInputManager->isWindowInhibiting(w, false) ? "true" : "false"), escapeJSONStrings(w->xdgTag().value_or("")), escapeJSONStrings(w->xdgDescription().value_or("")),
             escapeJSONStrings(NContentType::toString(w->getContentType())));
     } else {
         return std::format(
             "Window {:x} -> {}:\n\tmapped: {}\n\thidden: {}\n\tat: {},{}\n\tsize: {},{}\n\tworkspace: {} ({})\n\tfloating: {}\n\tpseudo: {}\n\tmonitor: {}\n\tclass: {}\n\ttitle: "
             "{}\n\tinitialClass: {}\n\tinitialTitle: {}\n\tpid: "
-            "{}\n\txwayland: {}\n\tpinned: "
+            "{}\n\txwayland: {}\n\tpinned: {}\n\talwaysOnTop: "
             "{}\n\tfullscreen: {}\n\tfullscreenClient: {}\n\tgrouped: {}\n\ttags: {}\n\tswallowing: {:x}\n\tfocusHistoryID: {}\n\tinhibitingIdle: {}\n\txdgTag: "
             "{}\n\txdgDescription: {}\n\tcontentType: {}\n\n",
             rc<uintptr_t>(w.get()), w->m_title, sc<int>(w->m_isMapped), sc<int>(w->isHidden()), sc<int>(w->m_realPosition->goal().x), sc<int>(w->m_realPosition->goal().y),
             sc<int>(w->m_realSize->goal().x), sc<int>(w->m_realSize->goal().y), w->m_workspace ? w->workspaceID() : WORKSPACE_INVALID,
             (!w->m_workspace ? "" : w->m_workspace->m_name), sc<int>(w->m_isFloating), sc<int>(w->m_isPseudotiled), w->monitorID(), w->m_class, w->m_title, w->m_initialClass,
-            w->m_initialTitle, w->getPID(), sc<int>(w->m_isX11), sc<int>(w->m_pinned), sc<uint8_t>(w->m_fullscreenState.internal), sc<uint8_t>(w->m_fullscreenState.client),
-            getGroupedData(w, format), getTagsData(w, format), rc<uintptr_t>(w->m_swallowed.get()), getFocusHistoryID(w), sc<int>(g_pInputManager->isWindowInhibiting(w, false)),
-            w->xdgTag().value_or(""), w->xdgDescription().value_or(""), NContentType::toString(w->getContentType()));
+            w->m_initialTitle, w->getPID(), sc<int>(w->m_isX11), sc<int>(w->m_pinned), (int)w->m_alwaysOnTop, sc<uint8_t>(w->m_fullscreenState.internal),
+            sc<uint8_t>(w->m_fullscreenState.client), getGroupedData(w, format), getTagsData(w, format), rc<uintptr_t>(w->m_swallowed.get()), getFocusHistoryID(w),
+            sc<int>(g_pInputManager->isWindowInhibiting(w, false)), w->xdgTag().value_or(""), w->xdgDescription().value_or(""), NContentType::toString(w->getContentType()));
     }
 }
 
diff --git a/src/desktop/rule/Rule.cpp b/src/desktop/rule/Rule.cpp
index 3d981587..4921299e 100644
--- a/src/desktop/rule/Rule.cpp
+++ b/src/desktop/rule/Rule.cpp
@@ -21,6 +21,7 @@ static const std::unordered_map<eRuleProperty, std::string> MATCH_PROP_STRINGS =
     {RULE_PROP_XWAYLAND, "xwayland"},                                  //
     {RULE_PROP_FULLSCREEN, "fullscreen"},                              //
     {RULE_PROP_PINNED, "pin"},                                         //
+    {RULE_PROP_ALWAYS_ON_TOP, "always_on_top"},                        //
     {RULE_PROP_FOCUS, "focus"},                                        //
     {RULE_PROP_GROUP, "group"},                                        //
     {RULE_PROP_MODAL, "modal"},                                        //
@@ -42,6 +43,7 @@ static const std::unordered_map<eRuleProperty, eRuleMatchEngine> RULE_ENGINES =
     {RULE_PROP_XWAYLAND, RULE_MATCH_ENGINE_BOOL},                //
     {RULE_PROP_FULLSCREEN, RULE_MATCH_ENGINE_BOOL},              //
     {RULE_PROP_PINNED, RULE_MATCH_ENGINE_BOOL},                  //
+    {RULE_PROP_ALWAYS_ON_TOP, RULE_MATCH_ENGINE_BOOL},           //
     {RULE_PROP_FOCUS, RULE_MATCH_ENGINE_BOOL},                   //
     {RULE_PROP_GROUP, RULE_MATCH_ENGINE_BOOL},                   //
     {RULE_PROP_MODAL, RULE_MATCH_ENGINE_BOOL},                   //
diff --git a/src/desktop/rule/Rule.hpp b/src/desktop/rule/Rule.hpp
index 2b852b3a..5bcbf2a9 100644
--- a/src/desktop/rule/Rule.hpp
+++ b/src/desktop/rule/Rule.hpp
@@ -31,6 +31,7 @@ namespace Desktop::Rule {
         RULE_PROP_XDG_TAG                  = (1 << 16),
         RULE_PROP_NAMESPACE                = (1 << 17),
         RULE_PROP_EXEC_TOKEN               = (1 << 18),
+        RULE_PROP_ALWAYS_ON_TOP            = (1 << 19),
 
         RULE_PROP_ALL = std::numeric_limits<std::underlying_type_t<eRuleProperty>>::max(),
     };
@@ -81,4 +82,4 @@ namespace Desktop::Rule {
             Time::steady_tp expiresAt;
         } m_execData;
     };
-}
\ No newline at end of file
+}
diff --git a/src/desktop/rule/windowRule/WindowRule.cpp b/src/desktop/rule/windowRule/WindowRule.cpp
index d1994d2e..2ec061b5 100644
--- a/src/desktop/rule/windowRule/WindowRule.cpp
+++ b/src/desktop/rule/windowRule/WindowRule.cpp
@@ -72,6 +72,10 @@ bool CWindowRule::matches(PHLWINDOW w, bool allowEnvLookup) {
                 if (!engine->match(w->m_pinned))
                     return false;
                 break;
+            case RULE_PROP_ALWAYS_ON_TOP:
+                if (!engine->match(w->m_alwaysOnTop))
+                    return false;
+                break;
             case RULE_PROP_FOCUS:
                 if (!engine->match(Desktop::focusState()->window() == w))
                     return false;
diff --git a/src/desktop/rule/windowRule/WindowRuleApplicator.cpp b/src/desktop/rule/windowRule/WindowRuleApplicator.cpp
index ab1c2a14..1c75cf92 100644
--- a/src/desktop/rule/windowRule/WindowRuleApplicator.cpp
+++ b/src/desktop/rule/windowRule/WindowRuleApplicator.cpp
@@ -514,6 +514,10 @@ CWindowRuleApplicator::SRuleResult CWindowRuleApplicator::applyStaticRule(const
                 static_.pin = truthy(effect);
                 break;
             }
+            case WINDOW_RULE_EFFECT_ALWAYSONTOP: {
+                static_.alwaysOnTop = truthy(effect);
+                break;
+            }
             case WINDOW_RULE_EFFECT_GROUP: {
                 static_.group = effect;
                 break;
diff --git a/src/desktop/rule/windowRule/WindowRuleApplicator.hpp b/src/desktop/rule/windowRule/WindowRuleApplicator.hpp
index 121de727..7afd8060 100644
--- a/src/desktop/rule/windowRule/WindowRuleApplicator.hpp
+++ b/src/desktop/rule/windowRule/WindowRuleApplicator.hpp
@@ -45,6 +45,7 @@ namespace Desktop::Rule {
             std::optional<bool>      maximize;
             std::optional<bool>      pseudo;
             std::optional<bool>      pin;
+            std::optional<bool>      alwaysOnTop;
             std::optional<bool>      noInitialFocus;
             std::optional<bool>      center;
 
diff --git a/src/desktop/rule/windowRule/WindowRuleEffectContainer.cpp b/src/desktop/rule/windowRule/WindowRuleEffectContainer.cpp
index 660bf871..d3cb8172 100644
--- a/src/desktop/rule/windowRule/WindowRuleEffectContainer.cpp
+++ b/src/desktop/rule/windowRule/WindowRuleEffectContainer.cpp
@@ -24,6 +24,7 @@ static const std::vector<std::string> EFFECT_STRINGS = {
     "workspace",              //
     "no_initial_focus",       //
     "pin",                    //
+    "always_on_top",          //
     "group",                  //
     "suppress_event",         //
     "content",                //
@@ -69,7 +70,7 @@ static const std::vector<std::string> EFFECT_STRINGS = {
 
 // This is here so that if we change the rules, we get reminded to update
 // the strings.
-static_assert(WINDOW_RULE_EFFECT_LAST_STATIC == 54);
+static_assert(WINDOW_RULE_EFFECT_LAST_STATIC == 55);
 
 CWindowRuleEffectContainer::CWindowRuleEffectContainer() : IEffectContainer<eWindowRuleEffect>(std::vector<std::string>{EFFECT_STRINGS}) {
     ;
diff --git a/src/desktop/rule/windowRule/WindowRuleEffectContainer.hpp b/src/desktop/rule/windowRule/WindowRuleEffectContainer.hpp
index 0827d462..edce3e9a 100644
--- a/src/desktop/rule/windowRule/WindowRuleEffectContainer.hpp
+++ b/src/desktop/rule/windowRule/WindowRuleEffectContainer.hpp
@@ -23,6 +23,7 @@ namespace Desktop::Rule {
         WINDOW_RULE_EFFECT_WORKSPACE,
         WINDOW_RULE_EFFECT_NOINITIALFOCUS,
         WINDOW_RULE_EFFECT_PIN,
+        WINDOW_RULE_EFFECT_ALWAYSONTOP,
         WINDOW_RULE_EFFECT_GROUP,
         WINDOW_RULE_EFFECT_SUPPRESSEVENT,
         WINDOW_RULE_EFFECT_CONTENT,
@@ -76,4 +77,4 @@ namespace Desktop::Rule {
     };
 
     SP<CWindowRuleEffectContainer> windowEffects();
-};
\ No newline at end of file
+};
diff --git a/src/desktop/view/Window.cpp b/src/desktop/view/Window.cpp
index 32a0086e..62ef52be 100644
--- a/src/desktop/view/Window.cpp
+++ b/src/desktop/view/Window.cpp
@@ -2057,6 +2057,7 @@ void CWindow::mapWindow() {
         m_isPseudotiled  = m_ruleApplicator->static_.pseudo.value_or(m_isPseudotiled);
         m_noInitialFocus = m_ruleApplicator->static_.noInitialFocus.value_or(m_noInitialFocus);
         m_pinned         = m_ruleApplicator->static_.pin.value_or(m_pinned);
+        m_alwaysOnTop    = m_ruleApplicator->static_.alwaysOnTop.value_or(m_alwaysOnTop);
 
         if (m_ruleApplicator->static_.fullscreenStateClient || m_ruleApplicator->static_.fullscreenStateInternal) {
             requestedFSState = Desktop::View::SFullscreenState{
@@ -2146,6 +2147,9 @@ void CWindow::mapWindow() {
     if (m_pinned && !m_isFloating)
         m_pinned = false;
 
+    if (m_alwaysOnTop && !m_isFloating)
+        m_alwaysOnTop = false;
+
     CVarList2 WORKSPACEARGS = CVarList2(std::move(requestedWorkspace), 0, ' ', false, false);
 
     if (!WORKSPACEARGS[0].empty()) {
diff --git a/src/desktop/view/Window.hpp b/src/desktop/view/Window.hpp
index d5c86aac..460c923e 100644
--- a/src/desktop/view/Window.hpp
+++ b/src/desktop/view/Window.hpp
@@ -183,6 +183,9 @@ namespace Desktop::View {
         // For pinned (sticky) windows
         bool m_pinned = false;
 
+        // For placing above other windows in the workspace
+        bool m_alwaysOnTop = false;
+
         // For preserving pinned state when fullscreening a pinned window
         bool m_pinFullscreened = false;
 
diff --git a/src/layout/IHyprLayout.cpp b/src/layout/IHyprLayout.cpp
index 8a33928b..408fd2c7 100644
--- a/src/layout/IHyprLayout.cpp
+++ b/src/layout/IHyprLayout.cpp
@@ -749,7 +749,8 @@ void IHyprLayout::changeWindowFloatingMode(PHLWINDOW pWindow) {
         g_pCompositor->setWindowFullscreenInternal(pWindow, FSMODE_NONE);
     }
 
-    pWindow->m_pinned = false;
+    pWindow->m_pinned      = false;
+    pWindow->m_alwaysOnTop = false;
 
     g_pHyprRenderer->damageWindow(pWindow, true);
 
diff --git a/src/managers/KeybindManager.cpp b/src/managers/KeybindManager.cpp
index c4d8734e..33202db3 100644
--- a/src/managers/KeybindManager.cpp
+++ b/src/managers/KeybindManager.cpp
@@ -134,6 +134,7 @@ CKeybindManager::CKeybindManager() {
     m_dispatchers["swapnext"]                       = swapnext;
     m_dispatchers["swapactiveworkspaces"]           = swapActiveWorkspaces;
     m_dispatchers["pin"]                            = pinActive;
+    m_dispatchers["togglealwaysontop"]              = toggleActiveAlwaysOnTop;
     m_dispatchers["mouse"]                          = mouse;
     m_dispatchers["bringactivetotop"]               = bringActiveToTop;
     m_dispatchers["alterzorder"]                    = alterZOrder;
@@ -2727,6 +2728,30 @@ SDispatchResult CKeybindManager::pinActive(std::string args) {
     return {};
 }
 
+SDispatchResult CKeybindManager::toggleActiveAlwaysOnTop(std::string args) {
+
+    PHLWINDOW PWINDOW = nullptr;
+
+    if (args != "active" && args.length() > 1)
+        PWINDOW = g_pCompositor->getWindowByRegex(args);
+    else
+        PWINDOW = Desktop::focusState()->window();
+
+    if (!PWINDOW) {
+        Log::logger->log(Log::ERR, "togglealwaysontop: window not found");
+        return {.success = false, .error = "togglealwaysontop: window not found"};
+    }
+
+    if (!PWINDOW->m_isFloating || PWINDOW->isFullscreen())
+        return {};
+
+    PWINDOW->m_alwaysOnTop = !PWINDOW->m_alwaysOnTop;
+
+    PWINDOW->m_ruleApplicator->propertiesChanged(Desktop::Rule::RULE_PROP_ALWAYS_ON_TOP);
+
+    return {};
+}
+
 SDispatchResult CKeybindManager::mouse(std::string args) {
     const auto ARGS    = CVarList(args.substr(1), 2, ' ');
     const auto PRESSED = args[0] == '1';
diff --git a/src/managers/KeybindManager.hpp b/src/managers/KeybindManager.hpp
index d4b1bf66..dd9a5745 100644
--- a/src/managers/KeybindManager.hpp
+++ b/src/managers/KeybindManager.hpp
@@ -225,6 +225,7 @@ class CKeybindManager {
     static SDispatchResult swapnext(std::string);
     static SDispatchResult swapActiveWorkspaces(std::string);
     static SDispatchResult pinActive(std::string);
+    static SDispatchResult toggleActiveAlwaysOnTop(std::string);
     static SDispatchResult mouse(std::string);
     static SDispatchResult bringActiveToTop(std::string);
     static SDispatchResult alterZOrder(std::string);
diff --git a/src/render/Renderer.cpp b/src/render/Renderer.cpp
index 1ee65a0f..7f06f0db 100644
--- a/src/render/Renderer.cpp
+++ b/src/render/Renderer.cpp
@@ -363,8 +363,8 @@ void CHyprRenderer::renderWorkspaceWindowsFullscreen(PHLMONITOR pMonitor, PHLWOR
 
     // then render windows over fullscreen.
     for (auto const& w : g_pCompositor->m_windows) {
-        if (w->workspaceID() != pWorkspaceWindow->workspaceID() || !w->m_isFloating || (!w->m_createdOverFullscreen && !w->m_pinned) || (!w->m_isMapped && !w->m_fadingOut) ||
-            w->isFullscreen())
+        if (w->workspaceID() != pWorkspaceWindow->workspaceID() || !w->m_isFloating || (!w->m_createdOverFullscreen && !w->m_pinned && !w->m_alwaysOnTop) ||
+            (!w->m_isMapped && !w->m_fadingOut) || w->isFullscreen())
             continue;
 
         if (w->m_monitor == pWorkspace->m_monitor && pWorkspace->m_isSpecialWorkspace != w->onSpecialWorkspace())
@@ -458,7 +458,28 @@ void CHyprRenderer::renderWorkspaceWindows(PHLMONITOR pMonitor, PHLWORKSPACE pWo
         if (!w)
             continue;
 
-        if (!w->m_isFloating || w->m_pinned)
+        if (!w->m_isFloating || w->m_pinned || w->m_alwaysOnTop)
+            continue;
+
+        // some things may force us to ignore the special/not special disparity
+        const bool IGNORE_SPECIAL_CHECK = w->m_monitorMovedFrom != -1 && (w->m_workspace && !w->m_workspace->isVisible());
+
+        if (!IGNORE_SPECIAL_CHECK && pWorkspace->m_isSpecialWorkspace != w->onSpecialWorkspace())
+            continue;
+
+        if (pWorkspace->m_isSpecialWorkspace && w->m_monitor != pWorkspace->m_monitor)
+            continue; // special on another are rendered as a part of the base pass
+
+        // render the bad boy
+        renderWindow(w.lock(), pMonitor, time, true, RENDER_PASS_ALL);
+    }
+
+    // always on top floating windows
+    for (auto& w : windows) {
+        if (!w)
+            continue;
+
+        if (!w->m_alwaysOnTop || !w->m_isFloating || w->m_pinned)
             continue;
 
         // some things may force us to ignore the special/not special disparity
